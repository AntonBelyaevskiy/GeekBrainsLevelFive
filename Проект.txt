Проект готов (ну, по крайней меря я так думаю).
Отправка файлов в обе стороны работает (как больших, так и маленьких)
Работает Drag And Drop при копировании файлов с компа на локальный репозиторий
Для загрузки в локальное хранилище, можно использовать FileChooser


Вопросы:
С сервера у меня файлы могут отправляться асинхронно (поскольку Netty), на сервер при отправке
всё приложение блокируется, пока файл полностью не отправиться на сервер (поскольку io).
Пытался отправлять файлы в отдельных потоках, но при этом периодически вылетают Exception.
Чтобы осуществить возможность отправки файлов на сервер асинхронно, нужно заменить реализацию клиента
с io на netty или nio?

Для развертывания приложения на сервере и использования клиента на компьютере, мы ведь будем собирать
проект в jar? Получается папки, в которых будут храниться файлы, должны будут лежать вне jar-пакета?
Нужно будет предусмотреть возможность для клиента выбрать папку, в которой у него на компьютере будут
храниться файлы для локального репозитория?

И будем ли мы рассматривать, то как правильно развернуть приложение, чтобы оно функционировало?
А то обычно делаем проект и запускаем его из среды разработки, а то как сделать так, чтобы проект работал вне среды,
не рассматриваем.

/////////////////////////КЛИЕНТ/////////////////////////

Основной контроллер//////////////////////////////////////////////////////
public class CloudController {

    @FXML
    public Button download;
    @FXML
    public Button refreshCloudFile;
    @FXML
    public Button deleteCloudFile;
    @FXML
    public Button deleteLocalFile;
    @FXML
    public Button upload;
    @FXML
    public TextField loginRegisterTextField;
    @FXML
    public PasswordField passwordRegisterTextField;
    @FXML
    public TextField loginTextField;
    @FXML
    public PasswordField passwordTextField;
    @FXML
    public Text serviceMessage;
    @FXML
    public Button fileChooser;
    @FXML
    public Button refreshLocalFile;
    @FXML
    public Button exitFromCloud;

    @FXML
    private CloudNetwork network;

    @FXML
    public VBox loginPane;
    @FXML
    public VBox cloudPane;
    @FXML
    public VBox registrationPane;

    @FXML
    private TableView<ElementForTableView> localTableView;
    @FXML
    private TableColumn<ElementForTableView, String> localFileName;
    @FXML
    private TableColumn<ElementForTableView, String> localFileSize;
    @FXML
    private TableColumn<ElementForTableView, Date> localFileCreateDate;

    private ObservableList<ElementForTableView> localItems = FXCollections.observableArrayList();
    private static ArrayList<ElementForTableView> cloudStorage = new ArrayList<>();

    @FXML
    private TableView<ElementForTableView> cloudTableView;
    @FXML
    private TableColumn<ElementForTableView, String> cloudFileName;
    @FXML
    private TableColumn<ElementForTableView, String> cloudFileSize;
    @FXML
    private TableColumn<ElementForTableView, Date> cloudFileCreateDate;

    private ObservableList<ElementForTableView> cloudItems = FXCollections.observableArrayList();

    @FXML
    public void initialize() {

        initDragAndDropFile();

        //настройка визуальных эффектов для ГПИ
        localFileName.prefWidthProperty().bind(localTableView.widthProperty().divide(2.0));
        localFileSize.prefWidthProperty().bind(localTableView.widthProperty().divide(5.8));
        localFileCreateDate.prefWidthProperty().bind(localTableView.widthProperty().divide(3.1));

        cloudFileName.prefWidthProperty().bind(cloudTableView.widthProperty().divide(2.0));
        cloudFileSize.prefWidthProperty().bind(cloudTableView.widthProperty().divide(5.8));
        cloudFileCreateDate.prefWidthProperty().bind(cloudTableView.widthProperty().divide(3.1));

        download.setCursor(Cursor.HAND);
        upload.setCursor(Cursor.HAND);
        deleteCloudFile.setCursor(Cursor.HAND);
        deleteLocalFile.setCursor(Cursor.HAND);
        refreshCloudFile.setCursor(Cursor.HAND);
        refreshLocalFile.setCursor(Cursor.HAND);
        fileChooser.setCursor(Cursor.HAND);
        exitFromCloud.setCursor(Cursor.HAND);

        //progressBar.progressProperty().setValue(0);
    }

    //////////БЛОК геттеров и сеттеров

    public static ArrayList<ElementForTableView> getCloudStorage() {
        return cloudStorage;
    }

    public static void setCloudStorage(ArrayList<ElementForTableView> cloudStorage) {
        CloudController.cloudStorage = cloudStorage;
    }

    //////////БЛОК обработка кнопок окна приветствия

    //действия при нажатии на кнопку войти
    public void goToCloud(ActionEvent actionEvent) {
        //если поля не заполнены выдать сообщение о необходимости заполнения
        if (loginTextField.getText().trim().equals("")) {
            serviceMessage.setText("Вы не ввели логин");
            return;
        }
        if (passwordTextField.getText().trim().equals("")) {
            serviceMessage.setText("Вы не ввели пароль");
            return;
        }

        connect();
        network.sendAuthorizationMsg(loginTextField.getText(), passwordTextField.getText(), "/enter");
    }

    //действия при нажатии на кнопку зарегистрироваться
    public void goToRegistration(ActionEvent actionEvent) {
        changeScene(loginPane, registrationPane);
        loginTextField.clear();
        passwordTextField.clear();
    }

    //действия при нажатии кнопки назад при отображении регистрационного окна
    public void backToLogin(ActionEvent actionEvent) {
        changeScene(registrationPane, loginPane);
        loginRegisterTextField.clear();
        passwordRegisterTextField.clear();
    }

    private void changeScene(VBox hidePane, VBox showPane) {
        hidePane.setVisible(false);
        hidePane.setManaged(false);
        showPane.setVisible(true);
        showPane.setManaged(true);
        serviceMessage.setText("");
    }

    public void registerInCloud(ActionEvent actionEvent) {
        if (loginRegisterTextField.getText().startsWith(" ")) {
            serviceMessage.setText("Логин не может начинаться с пробела");
            return;
        }
        if (passwordRegisterTextField.getText().startsWith(" ")) {
            serviceMessage.setText("Пароль не может начинаться с пробела");
            return;
        }
        if (loginRegisterTextField.getText().trim().equals("")) {
            serviceMessage.setText("Вы не ввели логин");
            return;
        }
        if (passwordRegisterTextField.getText().trim().equals("")) {
            serviceMessage.setText("Вы не ввели пароль");
            return;
        }
        connect();
        network.sendAuthorizationMsg(loginRegisterTextField.getText(), passwordRegisterTextField.getText(), "/create");
    }


    //////////БЛОК обработка кнопок при работе с файлами

    //метод при помощи, которого отправляем файл в облако
    public void uploadFile(ActionEvent actionEvent) {

        //получаем название файла, в зависимости от того, какой файл в TableView выбран
        String name = getSelectedFileNameLocal(localTableView);
        if (name == null) {
            return;
        }
        network.uploadFileOnCloud(name);
    }

    //при загрузке файла с облака, отправляем команду и название файла
    public void downloadFileFromCloud(ActionEvent actionEvent) {
        String name = getSelectedFileNameCloud(cloudTableView);
        if (name == null) {
            return;
        }
        network.downloadFileFromCloud(name);
    }

    //метод для удаления файлов в локальном хранилище
    public void deleteFileOnLocalStorage(ActionEvent actionEvent) {
        //получаем название файла, в зависимости от того, какой файл в TableView выбран
        String name = getSelectedFileNameLocal(localTableView);
        if (name == null) {
            return;
        }
        //удаляем файл по его названию
        try {
            System.out.println("сейчас будет удален файл " + Paths.get("client/storage/" + name));
            Files.delete(Paths.get("client/storage/" + name));
            drawLocalTableView();//обновляем содержимое TableView локального хранилища
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void deleteFileOnCloudStorage(ActionEvent actionEvent) {
        String name = getSelectedFileNameCloud(cloudTableView);
        if (name == null) {
            return;
        }
        network.deleteFileOnCloudStorage(name);
    }


    //////////БЛОК вспомогательные методы

    //Подключаемся к серверу, если авторизация прошла успешно
    private void connect() {
        network = CloudNetwork.getNetwork(this);
        network.run();
    }

    //прорисовываем информацию о хранящихся файлах на локальном репозитории, в TableView
    public void drawLocalTableView() {
        localItems.clear();//сперва очищаем список, чтобы при каждом обновлении списка файлы не дублировались

        //пробигаемся по локальному репозиторию, чтобы собрать информацию о всех файлах
        Path pathToStorage = Paths.get("client/storage");
        walkToLocalDirectory(pathToStorage);

        //заполняем ячейки TableView значениями о файлах
        localTableView.itemsProperty().setValue(localItems);

        //говорим, что именно и в какой ячейке отрисовать
        localFileName.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getName()));
        localFileSize.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getSize()));
        localFileCreateDate.setCellValueFactory(param -> new SimpleObjectProperty<>(param.getValue().getCreateDate()));
    }

    //прорисовываем информацию о хранящихся файлах на облаке, в TableView
    //действия аналогичны прорисовки локального хранилища, только мы не пробигаемся по локальной папке,
    //а запрашиваем данные у сервера
    public void drawCloudTableView() {
        cloudItems.clear();
        cloudTableView.itemsProperty().setValue(cloudItems);

        cloudItems.addAll(network.getCloudFilesStorage());

        cloudFileName.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getName()));
        cloudFileSize.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().getSize()));
        cloudFileCreateDate.setCellValueFactory(param -> new SimpleObjectProperty<>(param.getValue().getCreateDate()));
    }

    //перебор файлов в локальном хранилище
    private void walkToLocalDirectory(Path path) {
        List<ElementForTableView> files = null;
        try {
            files = Files.list(path).map(ElementBuilder::buildElement).collect(Collectors.toList());
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (files != null) {
            localItems.addAll(files);
        }
    }

    public void showCloudWindowAfterLogin() {
        loginPane.setVisible(false);
        loginPane.setManaged(false);
        registrationPane.setVisible(false);
        registrationPane.setManaged(false);
        cloudPane.setVisible(true);
        cloudPane.setManaged(true);
        serviceMessage.setVisible(false);
        serviceMessage.setManaged(false);

    }

    //имя выбранного файла в локальном хранилище
    private String getSelectedFileNameLocal(TableView<ElementForTableView> tableView) {

        if (tableView == cloudTableView || tableView.getSelectionModel().getSelectedItem() == null) {
            return null;
        }
        ElementForTableView element = tableView.getSelectionModel().getSelectedItem();
        return element.getName();
    }

    //имя выбранного файла в облачном хранилище
    private String getSelectedFileNameCloud(TableView<ElementForTableView> tableView) {

        if (tableView == localTableView || tableView.getSelectionModel().getSelectedItem() == null) {
            return null;
        }
        ElementForTableView element = tableView.getSelectionModel().getSelectedItem();
        return element.getName();
    }

    public void chooseFile(ActionEvent actionEvent) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Выберите файл");
        File file = fileChooser.showOpenDialog(Main.getStage());
        if (file == null) {
            return;
        }
        Path src = file.toPath();
        Path dest = Paths.get("client/storage/" + file.getName());
        try {
            Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
        drawLocalTableView();
    }

    private void initDragAndDropFile() {
        localTableView.setOnDragOver(event -> {
            if (event.getGestureSource() != localTableView && event.getDragboard().hasFiles()) {
                event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
            }
            event.consume();
        });

        localTableView.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasFiles()) {
                for (File file : db.getFiles()) {
                    Path pathSrc = Paths.get(file.getAbsolutePath());
                    Path pathDes = Paths.get("client/storage/" + file.getName());
                    try {
                        Files.copy(pathSrc, pathDes, StandardCopyOption.REPLACE_EXISTING);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
            drawLocalTableView();
        });
    }

    public void updateCloudView() {
        drawCloudTableView();
    }

    public void updateLocalView() { drawLocalTableView();
    }

    public void exit() {
        cloudPane.setVisible(false);
        cloudPane.setManaged(false);
        loginPane.setVisible(true);
        loginPane.setManaged(true);
        loginTextField.clear();
        passwordTextField.clear();
        serviceMessage.setVisible(true);
        serviceMessage.setManaged(true);
        network.disconnect();
    }
}

Работа с сетью//////////////////////////////////////////////////////
public class CloudNetwork {

    private static final int PORT = 8189;
    private static final String SERVER_IP = "localhost";

    private static volatile CloudNetwork network;
    private static CloudController controller;

    private static Socket socket;

    private ObjectEncoderOutputStream encoder;
    private ObjectDecoderInputStream decoder;

    private CloudNetwork() {

    }

    public static CloudNetwork getNetwork(CloudController connectController) {
        if (network == null) {
            synchronized (CloudNetwork.class) {
                if (network == null) {
                    network = new CloudNetwork();
                    controller = connectController;
                }
            }
        }
        return network;
    }

    public void run() {

        try {
            socket = new Socket(SERVER_IP, PORT);
            encoder = new ObjectEncoderOutputStream(socket.getOutputStream());
            decoder = new ObjectDecoderInputStream(socket.getInputStream());

            //клиент в бесконечном цикле, будет слушать всё, что присылает ему сервер
            //запускаем в отдельном потоке, чтобы не блокировать выполнение работы клиента
            Thread workThread = new Thread(() -> {
                try {
                    while (true) {
                        //логика клиента
                        Object message = decoder.readObject();


                        //если с сервера прилетает список файлов, обновляем список на клиенте
                        if (message instanceof CloudFilesList) {
                            CloudFilesList msg = (CloudFilesList) message;
                            CloudController.setCloudStorage(msg.getServerStorageList());
                            controller.drawCloudTableView();

                        }

                        if (message instanceof CloudCommand) {
                            if (((CloudCommand) message).getCommandName().equals("/exit"))
                                System.exit(0);
                            else
                                doCommand((CloudCommand) message);
                        }
                        if (message instanceof CloudSmallFile) {
                            saveSmallFile((CloudSmallFile) message);
                        }
                        if (message instanceof CloudLargeFile) {
                            saveLargeFile((CloudLargeFile) message);
                        }

                    }
                } catch (IOException | ClassNotFoundException e) {
                    e.printStackTrace();
                } finally {
                    disconnect();
                }
            });
            workThread.setDaemon(true);
            workThread.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void disconnect() {
        try {
            socket.close();
            encoder.close();
            decoder.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("disconnect");
    }

    //обрабатываем команды, которые прилетают с сервера
    private void doCommand(CloudCommand message) {
        System.out.println(message.getCommandName());

        if (message.getCommandName().equals("/allowToEnter")) {
            controller.showCloudWindowAfterLogin();
            controller.drawLocalTableView();
            controller.drawCloudTableView();
        }

        if (message.getCommandName().equals("/busyLogin")) {
            controller.serviceMessage.setText("Пользователь с таким логином уже существует");
            controller.loginRegisterTextField.setText("");
            controller.passwordRegisterTextField.setText("");
        }

        if (message.getCommandName().equals("/wrongLoginOrPassword")) {
            controller.serviceMessage.setText("Неправильный логин или пароль");
            controller.loginTextField.setText("");
            controller.passwordTextField.setText("");
        }
    }

    //если из облака прилетает файл, то сохраняем его на локальном репозитории
    private void saveSmallFile(CloudSmallFile message) {
        Path path = Paths.get("client/storage/" + message.getName());
        byte[] content = message.getContent();

        try {
            if (Files.exists(path))
                Files.delete(path);

            Files.write(path, content, StandardOpenOption.CREATE_NEW);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            controller.drawLocalTableView();
        }
    }

    private void saveLargeFile(CloudLargeFile message) {
        Path path = Paths.get("client/storage/" + message.getName());
        byte[] contentPart = message.getContent();
        try {
            if (message.getPartNumber() == 1) {
                if (Files.exists(path))
                    Files.delete(path);
                Files.write(path, contentPart, StandardOpenOption.CREATE_NEW);
            } else {
                Files.write(path, contentPart, StandardOpenOption.APPEND);
                if (message.getPartNumber() == message.getParts()) {
                    controller.drawLocalTableView();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public ArrayList<ElementForTableView> getCloudFilesStorage() {
        return CloudController.getCloudStorage();
    }

    //метод, который отправляет наш файл в облако, методу необходимо сообщить название отправляемого файла
    public void uploadFileOnCloud(String name) {

        int partOfFile = 1024 * 1024 * 20;

        try {
            long size = Files.size(Paths.get("client/storage/" + name));
            if (size <= partOfFile) {
                sendSmallFile(name);
            } else {
                    int parts = (int) Math.ceil((double) (size / partOfFile));
                    sendLargeFile(name, parts);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void sendSmallFile(String name) {
        try {
            byte[] content = Files.readAllBytes(Paths.get("client/storage/" + name));
            CloudSmallFile file = new CloudSmallFile(name, content);
            encoder.writeObject(file);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void sendLargeFile(String name, int parts) {


        int part = 1;
        int partSizeOfFile = 1024 * 1024 * 20; //20 мегабайт
        int currentPlaceInArray = 0;
        int read;
        byte[] current = new byte[partSizeOfFile];

        try (InputStream fileForeSend = new BufferedInputStream(new FileInputStream("client/storage/" + name))) {

            System.out.println(Files.size(Paths.get("client/storage/" + name)));

            do {
                read = fileForeSend.read();
                if (read != -1) {
                    current[currentPlaceInArray++] = (byte) read;

                    if (currentPlaceInArray == partSizeOfFile) {
                        System.out.println(part + " middle");
                        CloudLargeFile file = new CloudLargeFile(name, current, parts, part++);
                        encoder.writeObject(file);
                        currentPlaceInArray = 0;
                    }
                } else {
                    byte[] lastPart = new byte[currentPlaceInArray];
                    System.arraycopy(current, 0, lastPart, 0, currentPlaceInArray);
                    System.out.println(part + " end");
                    CloudLargeFile file = new CloudLargeFile(name, lastPart, parts, part);
                    encoder.writeObject(file);
                }
            } while (read != -1);

        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public void downloadFileFromCloud(String name) {
            CloudCommand command = new CloudCommand("/downloadFile", name);
            try {
                encoder.writeObject(command);
            } catch (IOException e) {
                e.printStackTrace();
            }
    }

    public void deleteFileOnCloudStorage(String name) {
        CloudCommand command = new CloudCommand("/deleteFile", name);
        try {
            encoder.writeObject(command);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void sendAuthorizationMsg(String login, String password, String status) {
        CloudAuthorization authorization = new CloudAuthorization(login, password, status);
        try {
            encoder.writeObject(authorization);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

/////////////////////////СЕРВЕР/////////////////////////

Работа с Базой Данных//////////////////////////////////////////////////////

public class AuthorizationHandler {

    private Connection connection;
    private PreparedStatement preparedStatement;


    public void connect() {
        try {
            Class.forName("org.sqlite.JDBC");
            connection = DriverManager.getConnection("jdbc:sqlite:server/src/main/resources/cloudDB.db");
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }
    }

    public boolean addNewUser(String login, String password) {
        String sql = "INSERT INTO users(login, password) VALUES(?,?);";
        try {
            PreparedStatement insertPrepared = connection.prepareStatement(sql);
            insertPrepared.setString(1,login);
            insertPrepared.setString(2,password);
            insertPrepared.executeUpdate();
            return true;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public boolean isUserExist(String checkLogin, String checkPassword){
        String sql = "SELECT * FROM users WHERE login = ? AND password = ?;";
        try {
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1,checkLogin);
            preparedStatement.setString(2,checkPassword);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                if(resultSet.getString("login").equals(checkLogin)
                        && resultSet.getString("password").equals(checkPassword))
                    return true;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public boolean isLoginNameNotBusy(String checkLogin){
        String sql = "SELECT login FROM users WHERE login = ?;";
        try {
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1,checkLogin);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                if(resultSet.getString("login").equals(checkLogin))
                    return false;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return true;
    }

    public boolean isLoginNameExist(String checkLogin){
        String sql = "SELECT * FROM users WHERE login = ?;";
        try {
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1,checkLogin);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                if(resultSet.getString("login").equals(checkLogin))
                    return true;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public void disconnect() {
        try {
            if (!preparedStatement.isClosed())
                preparedStatement.close();
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

Обработка запросов аутентификации//////////////////////////////////////////////////////

public class CloudAuthGateway extends ChannelInboundHandlerAdapter {

    AuthorizationHandler handler = new AuthorizationHandler();

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

        try {
            if (msg == null)
                return;

            if (msg instanceof CloudAuthorization) {
                CloudAuthorization authorization = (CloudAuthorization) msg;
                if (authorization.getStatus().equals("/create")) {
                    handler.connect();

                    if (handler.isLoginNameNotBusy(authorization.getLogin())) {
                        handler.addNewUser(authorization.getLogin(), authorization.getPassword());
                        //серверу сказать, чтобы запомнил логин и отправил клиенту сообщение, чтобы юзера впустили в облако
                        ctx.fireChannelRead(msg);
                        ctx.channel().pipeline().remove(this);
                        handler.disconnect();
                    } else {
                        CloudCommand busyLogin = new CloudCommand("/busyLogin");
                        ctx.fireChannelRead(busyLogin);
                        handler.disconnect();
                    }
                }
                if (authorization.getStatus().equals("/enter")) {
                    handler.connect();

                    if(handler.isUserExist(authorization.getLogin(), authorization.getPassword())) {
                        ctx.fireChannelRead(msg);
                        ctx.channel().pipeline().remove(this);
                        handler.disconnect();
                    }else{
                        CloudCommand wrongLoginOrPassword = new CloudCommand("/wrongLoginOrPassword");
                        ctx.fireChannelRead(wrongLoginOrPassword);
                        handler.disconnect();
                    }
                }
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}

Обработка запросов//////////////////////////////////////////////////////

public class CloudServerHandler extends ChannelInboundHandlerAdapter {

    private String login;


    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {
            if (msg == null)
                return;

            if (msg instanceof CloudAuthorization) {
                CloudAuthorization message = (CloudAuthorization) msg;
                login = message.getLogin();
                CloudCommand admitUser = new CloudCommand("/allowToEnter");
                if (message.getStatus().equals("/create")) {
                    //создаем папку для юзера
                    Files.createDirectories(Paths.get("server/storage/" + login));
                    //отправляем команду, чтобы юзера впустили в облако
                    ctx.write(admitUser);
                    sendFileListToClient(ctx);
                }
                if (message.getStatus().equals("/enter")) {
                    //отправляем команду, чтобы юзера впустили в облако
                    ctx.write(admitUser);
                    sendFileListToClient(ctx);
                }
            }

            //действия, если прилетела команда
            else if (msg instanceof CloudCommand) {
                Path path = Paths.get("server/storage/" + login + "/" + ((CloudCommand) msg).getFileName());
                switch (((CloudCommand) msg).getCommandName()) {
                    case "/downloadFile":
                        long size = Files.size(path);
                        int partOfFile = 1024 * 500 ;
                        int parts = (int) Math.ceil((double) (size / partOfFile));

                        if (size > partOfFile) {
                            sendLargeFile(path, parts, ctx); //отправляем частями
                        } else {
                            CloudSmallFile file = takeFile(((CloudCommand) msg).getFileName());
                            ctx.write(file);
                        }
                        break;
                    case "/deleteFile":
                        System.out.println(path);
                        Files.delete(path);
                        sendFileListToClient(ctx);
                        break;
                    case "/busyLogin":
                        ctx.write(msg);
                        break;
                    case "/wrongLoginOrPassword":
                        ctx.write(msg);
                        break;
                }
            }
            //действия, если прилетел маленький файл
            else if (msg instanceof CloudSmallFile) {
                System.out.println("file came on server " + ((CloudSmallFile) msg).getName());
                Path path = Paths.get("server/storage/" + login + "/" + ((CloudSmallFile) msg).getName());
                byte[] content = ((CloudSmallFile) msg).getContent();
                if (Files.exists(path)) {
                    Files.delete(path);
                    makeFile(path, content);
                } else {
                    makeFile(path, content);
                }
                //после того, как создали файл, сообщаем клиенту, что список файлов обновился
                sendFileListToClient(ctx);
            }
            //действия, если прилетел большой файл
            else if (msg instanceof CloudLargeFile) {
                System.out.println("file came on server "
                        + ((CloudLargeFile) msg).getName()
                        + " file part: "
                        + ((CloudLargeFile) msg).getPartNumber());
                Path path = Paths.get("server/storage/" + login + "/" + ((CloudLargeFile) msg).getName());

                if (((CloudLargeFile) msg).getPartNumber() == 1) {
                    byte[] content = ((CloudLargeFile) msg).getContent();
                    if (Files.exists(path)) {
                        Files.delete(path);
                        makeFile(path, content);
                    } else {
                        makeFile(path, content);
                    }
                } else {
                    byte[] content = ((CloudLargeFile) msg).getContent();
                    Files.write(path, content, StandardOpenOption.APPEND);
                }
                sendFileListToClient(ctx);

            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    private void sendFileListToClient(ChannelHandlerContext ctx) {
        CloudFilesList message = new CloudFilesList(login);
        ArrayList<ElementForTableView> files = walkToLocalDirectory(login);
        message.setServerStorageList(files);
        ctx.write(message);
    }

    private void makeFile(Path path, byte[] content) throws IOException {
        Files.write(path, content, StandardOpenOption.CREATE_NEW);
    }

    private CloudSmallFile takeFile(String fileName) {
        Path path = Paths.get("server/storage/" + login + "/" + fileName);
        byte[] content = new byte[(int) path.toFile().length()];
        try {
            content = Files.readAllBytes(path);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return new CloudSmallFile(fileName, content);
    }

    private void sendLargeFile(Path path, int parts, ChannelHandlerContext ctx) {

        int part = 1;
        int partSizeOfFile = 1024 * 500; //0.5 мегабайт
        int currentPlaceInArray = 0;
        int read;
        byte[] current = new byte[partSizeOfFile];

        try (InputStream fileForeSend = new BufferedInputStream(new FileInputStream(String.valueOf(path)))) {

            do {
                read = fileForeSend.read();
                if (read != -1) {
                    current[currentPlaceInArray++] = (byte) read;

                    if (currentPlaceInArray == partSizeOfFile) {
                        CloudLargeFile file = new CloudLargeFile(
                                path.getFileName().toString(),
                                current,
                                parts,
                                part);
                        ctx.write(file);

                        currentPlaceInArray = 0;
                        System.out.println("ser midl part " + part);
                        part++;
                    }
                }
                else {
                    byte[] lastPart = new byte[currentPlaceInArray];
                    System.arraycopy(current,0,lastPart,0,currentPlaceInArray);
                    CloudLargeFile file = new CloudLargeFile(
                            path.getFileName().toString(),
                            lastPart,
                            parts,
                            part);
                    ctx.write(file);
                    System.out.println("ser end part " + part);
                }
            } while (read != -1);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }

    private ArrayList<ElementForTableView> walkToLocalDirectory(String login) {
        ArrayList<ElementForTableView> files = new ArrayList<>();
        try {
            files = (ArrayList<ElementForTableView>) Files.list(Paths.get("server/storage/" + login))
                    .map(ElementBuilder::buildElement)
                    .collect(Collectors.toList());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return files;
    }
}

Настройка сервера//////////////////////////////////////////////////////

public class CloudServer {

    private static final int MAX_OBJ_SIZE = 1024 * 1024 * 30;
    private static final int PORT = 8189;

    public void run() {
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workGroup = new NioEventLoopGroup();

        try {
            ServerBootstrap boot = new ServerBootstrap();
            boot.group(mainGroup, workGroup).channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(
                                    new ObjectDecoder(MAX_OBJ_SIZE, ClassResolvers.cacheDisabled(null)),
                                    new ObjectEncoder(),
                                    new CloudAuthGateway(),
                                    new CloudServerHandler()
                            );
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .option(ChannelOption.TCP_NODELAY, true)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);

            ChannelFuture channelFuture = boot.bind(PORT).sync();
            channelFuture.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            mainGroup.shutdownGracefully();
            workGroup.shutdownGracefully();
        }
    }
}

/////////////////////////ОБЩИЕ КЛАССЫ/////////////////////////

Классы отправляемых данных на сервер//////////////////////////////////////////////////////

////авторизация
public class CloudAuthorization extends CloudMessage {

    private String login;
    private String password;
    private String status;

    public CloudAuthorization(String login, String password, String status) {
        this.login = login;
        this.password = password;
        this.status = status;
    }

    public String getLogin() {
        return login;
    }

    public String getPassword() {
        return password;
    }

    public String getStatus() {
        return status;
    }
}

////команды
public class CloudCommand extends CloudMessage {
    private String commandName;
    private String fileName;


    public CloudCommand(String commandName) {
        this.commandName = commandName;
    }

    public CloudCommand(String commandName, String fileName) {
        this.commandName = commandName;
        this.fileName = fileName;
    }

    public String getCommandName() {
        return commandName;
    }

    public String getFileName() {
        return fileName;
    }
}

////список файлов
public class CloudFilesList extends CloudMessage {

    private String login;
    private ArrayList<ElementForTableView> serverStorageList;

    public CloudFilesList(String login) {
        this.login = login;
        serverStorageList = new ArrayList<>();
    }

    public ArrayList<ElementForTableView> getServerStorageList() {
        return serverStorageList;
    }

    public void setServerStorageList(ArrayList<ElementForTableView> serverStorageList) {
        this.serverStorageList = serverStorageList;
    }
}

////большие файлы
public class CloudLargeFile extends CloudMessage {
    private String name;
    private byte[] content;
    private int parts;
    private int partNumber;

    public CloudLargeFile(String name, byte[] content, int parts, int numberOfPart) {
        this.name = name;
        this.content = content;
        this.parts = parts;
        this.partNumber = numberOfPart;
    }

    public String getName() {
        return name;
    }

    public byte[] getContent() {
        return content;
    }

    public int getParts() {
        return parts;
    }

    public int getPartNumber() {
        return partNumber;
    }
}

////маленькие файлы
public class CloudSmallFile extends CloudMessage {
    private String name;
    private byte[] content;

    public CloudSmallFile(String name, byte[] content) {
        this.name = name;
        this.content = content;
    }

    public String getName() {
        return name;
    }

    public byte[] getContent() {
        return content;
    }
}

//общий для всех
public abstract class CloudMessage implements Serializable {

}

Элементы размещаемые в TableView//////////////////////////////////////////////////////

////определение даты создания файла
public class ElementBuilder {

    public static ElementForTableView buildElement(Path path){
        try {
            BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes.class);
            return new ElementForTableView(path.getFileName().toString(),
                    String.valueOf(path.toFile().length()),
                    new Date(attributes.creationTime().to(TimeUnit.MILLISECONDS)));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return new ElementForTableView("no element","",null);
    }
}

////элементы (строчки в TableView)
public class ElementForTableView implements Serializable {

    private String name;
    private String size;
    private Date createDate;

    public ElementForTableView(String name, String size, Date createDate) {
        this.name = name;
        this.size = String.valueOf((int)Math.ceil((double) Integer.parseInt(size)/1024)) + " КБ";
        this.createDate = createDate;


    }

    public String getName() {
        return name;
    }

    public String getSize() {
        return size;
    }

    public Date getCreateDate() {
        return createDate;
    }
}